---
title: "Dan Gillen's Functions"
author: "Lidio Jaimes Jr"
date: "2025-03-19"
output: pdf_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
##
#####	Collection of functions written by D. Gillen that are used
#####	throughout Stat 211
#####
#####	Author: D. Gillen
#####	Course: Stat 211, Winter 2022
##
##
#####	Helper function to return vector for binary test
##
ifelse1 <- function (test, yes, no){
    if (test) yes
    else no
}

##
#####  Function to produce CIs for LM parameters (or exponentiated parameters)
##
lmCI <- function( model, expcoef=FALSE, robust=FALSE ){
	coef <- summary( model )$coef[,1]
	se <- ifelse1( robust, robust.se.lm(model)[,2], summary( model )$coef[,2] )
	tvalue <- coef / se
	pvalue <- 2*(1-pt(abs(tvalue), model$df.residual))
	if( expcoef ){
		ci95.lo <- exp( coef - qt(.975, model$df.residual) * se )
		ci95.hi <- exp( coef + qt(.975, model$df.residual) * se )
		est <- exp( coef )
	}
	else{
		ci95.lo <- coef - qt(.975, model$df.residual) * se
		ci95.hi <- coef + qt(.975, model$df.residual) * se
		est <- coef
	}
	rslt <- round( cbind( est, ci95.lo, ci95.hi, tvalue, pvalue ), 4 )
	colnames( rslt ) <- ifelse1( 	robust, 	
					c("Est", "robust ci95.lo", "robust ci95.hi", "robust t value", "robust Pr(>|t|)"),
					c("Est", "ci95.lo", "ci95.hi", "t value", "Pr(>|t|)") )			
	colnames( rslt )[1] <- ifelse( expcoef, "exp( Est )", "Est" )
	rslt
	}


##
#####	Function to plot dfBetas resulting from a lm() object
##
plot.dfbeta <- function( dfbeta.fit, labels ){
	oldmar <- par()$mar
	par( mar=c(5, 4, 3+.75*dim(dfbeta.fit)[2], 2) + 0.1 )
	plot( c(1,dim(dfbeta.fit)[1]*1.1), range(dfbeta.fit)*1.1, xlab="Observation", ylab="dfBeta", type="n" )
	for( i in 2:dim(dfbeta.fit)[2] ){
			points( 1:dim(dfbeta.fit)[1], dfbeta.fit[,i], col=i )
			text( 1:dim(dfbeta.fit)[1]+1, dfbeta.fit[,i]+.1, labels=labels, col=i )
			mtext( colnames( dfbeta.fit )[i], col=i, line=-1+i )
	}  
	abline( h=c(-1,1)*(2/sqrt(dim(dfbeta.fit)[1])), col="red", lwd=2 )
	par( mar=oldmar )
	}
	

##
##### 	Compute robust (sandwich) variance-covariance estimate for a LM
##
robust.vcov.lm <- function( lm.obj ){
  X <- model.matrix( lm.obj )
  eps <- lm.obj$residuals
  robust.cov <- solve( t(X)%*%X ) %*%( t(X) %*% diag(eps^2) %*% X ) %*% solve( t(X)%*%X )
  dimnames( robust.cov ) <- dimnames( vcov(lm.obj) )
  return( robust.cov )
}

##
#####
#####	robust.se.lm() is a function to compute the Huber-White sandwich variance estimator
#####	for the linear regression model
#####	
##
robust.se.lm <- function( model) { 
  s <- summary( model) 
  X <- model.matrix( model )
  sandwich.cov <- robust.vcov.lm( model )
  sand.se <- sqrt( diag( sandwich.cov )) 
  t <- model$coefficients/sand.se
  p <- 2*pt( -abs( t ), dim(X)[1]-dim(X)[2] ) 
  ci95.lo <- model$coefficients - qt( .975, dim(X)[1]-dim(X)[2] ) * sand.se
  ci95.hi <- model$coefficients + qt( .975, dim(X)[1]-dim(X)[2] ) * sand.se
  rslt <- cbind( model$coefficients, sand.se, ci95.lo, ci95.hi, t, p ) 
  dimnames(rslt)[[2]] <- c( dimnames( s$coefficients )[[2]][1], "Robust SE", "ci95.lo", "ci95.hi", dimnames( s$coefficients )[[2]][3:4] ) 
  rslt 
} 


##
#####  Function to exponentiate coefficients and produces CIs for GLMs
##
glmCI <- function( model, transform=TRUE, robust=FALSE ){
	link <- model$family$link
	coef <- summary( model )$coef[,1]
	se <- ifelse1( robust, robust.se.glm(model)[,2], summary( model )$coef[,2] )
	zvalue <- coef / se
	pvalue <- 2*(1-pnorm(abs(zvalue)))

	if( transform & is.element(link, c("logit","log")) ){
		ci95.lo <- exp( coef - qnorm(.975) * se )
		ci95.hi <- exp( coef + qnorm(.975) * se )
		est <- exp( coef )
	}
	else{
		ci95.lo <- coef - qnorm(.975) * se
		ci95.hi <- coef + qnorm(.975) * se
		est <- coef
	}
	rslt <- round( cbind( est, ci95.lo, ci95.hi, zvalue, pvalue ), 4 )
	colnames( rslt ) <- ifelse1( 	robust, 	
					c("Est", "robust ci95.lo", "robust ci95.hi", "robust z value", "robust Pr(>|z|)"),
					c("Est", "ci95.lo", "ci95.hi", "z value", "Pr(>|z|)") )			
	colnames( rslt )[1] <- ifelse( transform & is.element(link, c("logit","log")), "exp( Est )", "Est" )
	rslt
	}


##
#####  Function to collapse grouped binary data to binomial
##
collapse <- function( data, outcome ){
	index <- (1:length(names(data)))[ names(data)==outcome ]
	y <- data[,index]
	covnames <- names( data )[-index]
	data <- data[,-index]
	if( is.null( dim( data ) ) ){
		rslt <- aggregate( y, list(data), FUN=length)
		rslt <- as.data.frame( cbind( rslt, aggregate( y, list(data), FUN=sum)[dim(rslt)[2]] ) )
	}
	else{
		rslt <- aggregate( y, data, FUN=length)
		rslt <- as.data.frame( cbind( rslt, aggregate( y, data, FUN=sum)[dim(rslt)[2]] ) )
	}
	names( rslt ) <- c( covnames, "n", paste("n.", outcome, sep="") )
	rslt
}


##
#####	Function to compute deviance (LR) test p-Value
##
lrtest <- function( fit1, fit2 ){
	cat( "\nAssumption: Model 1 nested within Model 2\n\n" )
	rslt <- anova( fit1, fit2 )
	rslt <- cbind( rslt, c("", round( pchisq( rslt[2,4], rslt[2,3], lower.tail=FALSE ), 4 ) ) )
	rslt[,2] <- round( rslt[,2], 3 )
	rslt[,4] <- round( rslt[,4], 3 )
	rslt[1,3:4] <- c( "", "" )
	names( rslt )[5] <- "pValue"
	rslt
}


##
#####	H-L goodness of fit test
##
binary.gof <- function( fit, ngrp=10, print.table=TRUE ){
	y <- fit$y
	phat <- fitted( fit )
	fittedgrps <- cut( phat, quantile( phat, seq(0,1,by=1/ngrp) ), include.lowest=TRUE )
	n <- aggregate( y, list( fittedgrps ), FUN=length )[,2]
	Obs <- aggregate( y, list( fittedgrps ), FUN=sum )[,2]
	Exp <- aggregate( phat, list( fittedgrps ), FUN=sum )[,2]
	if( print.table==TRUE ){
		cat( "\nFitted Probability Table:\n\n" )
		rslt <- as.data.frame( cbind( 1:ngrp, n, Obs, Exp ) )
		names( rslt )[1] <- "group"
		print( rslt )
	}
	chisqstat <- sum( (Obs - Exp)^2 / ( Exp*(1-Exp/n) ) )
	df <- ngrp - 2
	pVal <- pchisq( chisqstat, df, lower.tail=FALSE )
	cat( "\n Hosmer-Lemeshow GOF Test:\n\n" )
	cbind( chisqstat, df, pVal )
}

##
##### 	Compute robust (sandwich) variance-covariance estimate for a GLM
##
robust.vcov.glm <- function(glm.obj){
	if (is.matrix(glm.obj$x)) 
		xmat<-glm.obj$x
	else {
		mf<-model.frame(glm.obj)
		xmat<-model.matrix(terms(glm.obj),mf)		
	}
	umat <- residuals(glm.obj,"working")*glm.obj$weights*xmat
	modelv<-summary(glm.obj)$cov.unscaled
	robust.cov <- modelv%*%(t(umat)%*%umat)%*%modelv
	dimnames( robust.cov ) <- dimnames( vcov(glm.obj) )
	return( robust.cov )
}
	
	
##
#####	Function to compute robust se for glms
##
robust.se.glm <- function(glm.obj){
	## 	Compute robust (sandwich) variance estimate
	robust.cov <- robust.vcov.glm(glm.obj)
	
	##	Format the model output with p-values and CIs
	s <- summary( glm.obj) 
	robust.se <- sqrt( diag( robust.cov )) 
	z <- glm.obj$coefficients/robust.se
	p <- 2*pnorm( -abs( z ) ) 
	ci95.lo <- glm.obj$coefficients - qnorm( .975 ) * robust.se
	ci95.hi <- glm.obj$coefficients + qnorm( .975 ) * robust.se
	rslt <- cbind( glm.obj$coefficients, robust.se, ci95.lo, ci95.hi, z, p ) 
	dimnames(rslt)[[2]] <- c( dimnames( s$coefficients )[[2]][1], "Robust SE", "ci95.lo", "ci95.hi", "z value", "Pr(>|z|)" ) 
	rslt 
	}

##
#####	Function to summarize the multinomial fit
##
summ.mfit <- function( model ){
	s <- summary( model )
	for( i in 1:length(model$coef) ){
		cat( "\nLevel ", model$lev[i+1],  "vs. Level ", model$lev[1], "\n" )
		coef <- s$coefficients[i,]
		rrr <- exp( coef )
		se <- s$standard.errors[i,]
		zStat <- coef / se
		pVal <- 2*pnorm( abs(zStat), lower.tail=FALSE )
		ci95.lo <- exp( coef - qnorm(.975)*se )
		ci95.hi <- exp( coef + qnorm(.975)*se )
		rslt <- cbind( rrr, se, zStat, pVal, ci95.lo, ci95.hi )
		print( round( rslt, 3 ) )
	}
}

#
##
#####	Function to summarize a proportional odds fit
##
olrCI <- function( model, transform=TRUE ){
		coef <- summary( model )$coef[ 1:length(model$coef), ]
		if( is.null( dim( coef ) ) ) coef <- t( as.matrix(coef) )
		zStat <- as.matrix(coef[,3])
		pVal <- 2*pnorm( abs(zStat),lower.tail=FALSE )
		if( transform ){
			ci95.lo <- exp( coef[,1] - qnorm(.975) * coef[,2] )
			ci95.hi <- exp( coef[,1] + qnorm(.975) * coef[,2] )
			est <- exp( coef[,1] )
		}
		else{
			ci95.lo <- coef[,1] - qnorm(.975) * coef[,2]
			ci95.hi <- coef[,1] + qnorm(.975) * coef[,2]
			est <- coef[,1]
		}
		rslt <- round( cbind( est, ci95.lo, ci95.hi, zStat, pVal), 4 )
		if( transform ) colnames( rslt ) <- c( "exp( Est )", "ci95.lo", "ci95.hi", "z value", "Pr(>|z|)" )
			else colnames( rslt ) <- c( "est", "ci95.lo", "ci95.hi", "z value", "Pr(>|z|)" )
		rslt
}


mvWald <- function(model, cov.names, robust=FALSE) {
  p <- length(model$coef)
  r <- length(cov.names)
  names.model <- names(model$coef)
  new.index <- c((1:p)[names.model %in% cov.names], (1:p)[!names.model %in%
                                                            cov.names])
  beta <- model$coef[new.index]
  if (robust)
    cov.beta <- robust.vcov.glm(model) else cov.beta <- vcov(model)
  Info <- solve(cov.beta[new.index, new.index])
  Info.11 <- Info[1:r, 1:r]
  Info.12 <- Info[1:r, (r + 1):p]
  Info.22 <- Info[(r + 1):p, (r + 1):p]
  Info.11.2 <- Info.11 - Info.12 %*% solve(Info.22) %*% t(Info.12)
  chiStat <- t(beta[1:r]) %*% Info.11.2 %*% beta[1:r]
  pVal <- 1 - pchisq(chiStat, df = r)
  rslt <- as.data.frame(cbind(round(chiStat, 2), round(r), round(pVal,3)))
  dimnames(rslt)[[2]] <- c("ChiStat", "DF", "pValue")
  cat("\nTest of H_0: ")
  for (i in 1:r) {
    if (i < r)
      cat(cov.names[i], " = ", sep = "") else cat(cov.names[i], " = 0 :\n\n", sep = "")
  }
  rslt
}

##  Example use
#mvWald(fit.1, cov.names = c("factor(k5)1", "factor(k5)2"), robust=TRUE )




linContr.glm <- function(contr.names, contr.coef = rep(1, length(contr.names)),
                         model, transform = TRUE, robust = FALSE) {
  beta.hat <- model$coef
  if (robust)
    cov.beta <- robust.vcov.glm(model) else cov.beta <- vcov(model)
  contr.index <- match(contr.names, dimnames(cov.beta)[[1]])
  beta.hat <- beta.hat[contr.index]
  cov.beta <- cov.beta[contr.index, contr.index]
  est <- contr.coef %*% beta.hat
  se.est <- sqrt(contr.coef %*% cov.beta %*% contr.coef)
  zStat <- est/se.est
  pVal <- 2 * pnorm(abs(zStat), lower.tail = FALSE)
  ci95.lo <- est - qnorm(0.975) * se.est
  ci95.hi <- est + qnorm(0.975) * se.est
  link <- model$family$link
  if (transform & is.element(link, c("logit", "log"))) {
    ci95.lo <- exp(ci95.lo)
    ci95.hi <- exp(ci95.hi)
    est <- exp(est)
    cat("\nTest of H_0: exp( ")
    for (i in 1:(length(contr.names) - 1)) {
      cat(contr.coef[i], "*", contr.names[i], " + ", sep = "")
    }
    cat(contr.coef[i + 1], "*", contr.names[i + 1], " ) = 1 :\n\n",
        sep = "")
  } else {
    cat("\nTest of H_0: ")
    for (i in 1:(length(contr.names) - 1)) {
      cat(contr.coef[i], "*", contr.names[i], " + ", sep = "")
    }
    cat(contr.coef[i + 1], "*", contr.names[i + 1], " = 0 :\n\n", sep = "")
  }
  rslt <- data.frame(est, se.est, zStat, pVal, ci95.lo, ci95.hi)
  colnames(rslt)[1] <- ifelse(transform && is.element(link, c("logit",
                                                              "log")), "exp( Est )", "Est")
  round(rslt, 3)
}
```


# Tables from Christina
```{r regression tables}
format_lm_output <- function(data, sigfigs = 2, robust = TRUE){
  ########## round significant figures 
  ########## use the format function with nsmall and digits = 2
  ########## exp( Est ) ci95.lo ci95.hi  z value Pr(>|z|)
  #keep <- c("exp( Est )", "ci95.lo", "ci95.hi", "Pr(>|z|)")
  # Est ci95.lo ci95.hi t value Pr(>|t|)
  
  if(robust){
    ### "Est", "robust ci95.lo", "robust ci95.hi", "robust z value", "robust Pr(>|z|)"
    keep <- c("Est", "robust ci95.lo", "robust ci95.hi", "robust Pr(>|t|)")
  } else {
    keep <- c("Est", "ci95.lo", "ci95.hi", "Pr(>|t|)")
  }
  ### if you are using a robust variance your arguments would be 
  
  output <- data[ , colnames(data) %in% keep]
  colnames(output) <- c("Est", "ci95.lo", "ci95.hi", "pval")
  output <- as.data.frame(output)
  
  output <- cbind(format(output$Est, nsmall = sigfigs , digits = sigfigs, scientific = FALSE )
                  , paste("(", format(output$ci95.lo, nsmall = sigfigs , digits = sigfigs, scientific = FALSE ), ",", format(output$ci95.hi, nsmall = sigfigs , digits = sigfigs, scientific = FALSE ),")")
                  , format(output$pval, nsmall = sigfigs, digits = sigfigs, scientific = FALSE)
  )
  
  colnames(output) <- c("Est", "95 C.I.", "P-Val")
  rownames(output) <- rownames(data)
  
  return(output)
  
}


table1_descriptive <- function(data, vars, group, categorical){
  # , sigdigits=2 may want to add this argument in later 
  
  n.var <- length(vars)
  
  groupcounts <- table(data[ , colnames(data) %in% group])
  
  groupNum <- paste("N = ", groupcounts)
  table_1 <- rbind(rownames(groupcounts), groupNum)
  
  for (i in 1:n.var) {
    
    if(vars[i] %in% categorical){
      
      counts <- table(data[ , colnames(data) %in% vars[i] ], data[, colnames(data) %in% group], useNA = "ifany")
      
      freq <- counts / matrix(rep(groupcounts, each = dim(counts)[1]), nrow = dim(counts)[1])
      freq <- format(freq, nsmall = 1, digits = 1)
      counts <- format(counts, nsmall = 2, digits = 2)
      
      temp <- matrix(paste(counts, "(", freq, ")"), nrow = dim(counts)[1]) # will have to format significant figures 
      rownames(counts) <- ifelse(is.na(rownames(counts)), "Missing", rownames(counts))
      rownames(temp) <- paste("    ", rownames(counts)) #for excel table 
      #rownames(temp) <- ifelse(is.na(rownames(temp)), "Missing", rownames(temp))
      #rownames(temp) <- paste("\\indent ", rownames(counts))
      #rownames(temp) <- paste("\\hspace{3mm} ", rownames(counts))
      #colnames(temp) <- colnames(counts)
      #colnames(temp) <- ifelse(is.na(colnames(temp)), "Missing", colnames(temp))
      
      filler <- matrix(rep("", length(groupcounts)), nrow = 1)
      rownames(filler) <- vars[i]
      colnames(filler) <- colnames(counts)
      
      table_1 <- rbind(table_1, filler, temp) 
      # appending to table 1
      
      
    } else{
      
      ########## mean 
      means_group <- tapply(data[ , colnames(data) %in% vars[i] ], data[, colnames(data) %in% group], mean, na.rm=TRUE)
      
      ########### formating sig figs
      means_group <- format(means_group, nsmall = 2, digits = 2)
      
      
      ############ sd 
      sds_group <- tapply(data[ , colnames(data) %in% vars[i] ], data[, colnames(data) %in% group], sd, na.rm=TRUE)
      
      
      ########### formating sig figs
      sds_group  <- format(sds_group, nsmall = 2, digits = 2)
      
      
      
      temp <- matrix(paste(means_group, "(", sds_group, ")"), nrow = 1) 
      
      colnames(temp) <- rownames(means_group)
      rownames(temp) <- vars[i]
      
      table_1 <- rbind(table_1, temp) 
      
      
    }
    
    
  }
  
  return(table_1)
}

dfbeta_lm_plots <- function(fit_model){

  deltabetas_model <- dfbeta(fit_model)
  
  for (i in 1:dim(deltabetas_model)[2]) {
    plot(seq(1:dim(deltabetas_model)[1]), deltabetas_model[, i], main = colnames(deltabetas_model)[i])
    
    # Add observation numbers as labels
    text(
      x = rownames(deltabetas_model), 
      y = deltabetas_model[, i], 
      labels = rownames(deltabetas_model), 
      pos = 4,  # Position labels to the right of the points
      cex = 0.7, # Size of text
      col = "red"
    )
  }
}

format_geeConstrast <- function(data_t){
  
  
  output <- cbind(
    data_t$Est
    , paste("(", data_t$ci95.lo, ",", data_t$ci95.hi, ")")
    , data_t$pVal)
  return(output)
  
}

dfbeta_geeglm_plots <- function(fit_model, data, family = gaussian, corstr = "ar1"){
  ######### library(geepack) using this function 
  #fit_model <- modelBaseline
  # data = ds_long_base
  
  gee_formula <- formula(fit_model)
  
  x_design <- as.data.frame(model.matrix(fit_model))
  subject_id <- data$subject_id[rownames(data) %in% as.numeric(rownames(x_design))]
  #y_vector <- model.response(model.frame(fit_model))
  #data_model <- as.data.frame(cbind(y_vector, x_design, subject_id))
  
  sub_unique <- unique(subject_id)
  n_unique <- length(sub_unique)
  
  beta0 <- coefficients(fit_model)
  
  
  delta_betas <- matrix(NA, ncol = dim(x_design)[2], nrow = n_unique)
  colnames(delta_betas) <- colnames(x_design)
  rownames(delta_betas) <- sub_unique 
  
  for (i in 1:n_unique) {
    delta_betas[i, ] <- coefficients(geeglm( gee_formula
                                             ,id = subject_id,
                                             data = data[data$subject_id != sub_unique[i],] ,
                                             ,family = family
                                             ,na.action = na.omit
                                             ,corstr = corstr)) - beta0
  }
  
  
  for (i in 1:dim(delta_betas)[2]) {
    plot(seq(1:dim(delta_betas)[1]), delta_betas[, i], main = colnames(delta_betas)[i])
    
    # Add observation numbers as labels
    text(
      x = seq(1:dim(delta_betas)[1]), 
      y = delta_betas[, i], 
      labels = unique(subject_id), 
      pos = 4,  # Position labels to the right of the points
      cex = 0.7, # Size of text
      col = "red"
    )
  }
  
  return(list(deltabetas = delta_betas))
}
```

